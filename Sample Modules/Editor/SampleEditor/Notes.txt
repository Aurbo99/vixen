DISCLAIMER:
This file is not meant to be a comprehensive guide or tutorial.  They are
some notes created while creating this project that may help you do the
same.

--== Sample Editor Module ==--

Editor modules are what users use to create a sequence.  Generally a Windows
forms application, but not necessarily.

An editor is probably the most difficult thing to implement because you're
interacting with a person.  Not to insult people, but we tend to poke and prod
things to see what they'll do and that can be a nightmare to anticipate.

There is nothing provided for you, UI-management wise.  That's entirely up to
you to implement.

===============================================================================

I will assume that you have used C# and Visual Studio before, but I will
try not to assume much more than that.

Step 1: Create a Class Library project.
Step 2: Reference Vixen.dll in the project.

Neither of those steps should require explanation.

A module may or may not have persisted data via a data object.
This sample project will because that's how effects' parameters
are persisted.

Step 3: Create some classes.

Use whatever names you like for these classes I'm about to describe.  But
if you're going to have more than one module in the assembly, you may want
to keep the names centered around the module (for example, instead of
calling a class "Descriptor", call it "RenardDescriptor").

Class 1: The descriptor class.
Class 2: The module class.

Make each of these classes public.

Each module type has base classes you can use to implement the mundane
members.  The descriptor is the easiest of the three, so I will start there.

Step 4: Create the descriptor.

Import namespaces: Vixen.Module.Editor
Derive from: EditorModuleDescriptorBase

Have Visual Studio implement the base class for you and you will see (not in this
order):

Author:      You. Duh.
Description: Anything you like.
TypeName:    The name of your module that users will see.
Version:     Not currently used, but it may be in the future.
TypeId:      A unique, *unique*, UNIQUE GUID that you generate.
             Yes, make sure it's unique and you didn't copy it
             from someone/somewhere else.  This is the value that
             uniquely indentifies your module.  If this conflicts
             with another module, neither module will be loaded.
ModuleClass: The type that implements your module (class 2 in this sample).

Module-specific members:

FileExtensions:           Generally, an editor works against a single kind of
                          file, but not required.  Give the extensions of the
                          file types the editor will handle.
EditorUserInterfaceClass: Since we're trying not to assume it is a Winforms
                          application, you have to provide the class that will
                          act as the user interface.  This will be covered in
                          step 6.

The descriptor is done.

Step 5: Create the module class.

Import namespaces: Vixen.Module, Vixen.Module.Editor
Derive from: EditorModuleInstanceBase

Normally, I'd say something like:
"Everything up until now has been to support this one class.  This is the class
that does everything.  It IS your module."

But not in this case.  In this case, the module is pretty much worthless.  It
sits around, eats your food, uses your electricity, and doesn't contribute a
thing.

What does matter is...

Step 6: Create the user interface.

This is the class type referenced by EditorUserInterfaceClass in the descriptor.
I'm going to go with the assumption that you're implementing a Windows form.
Add a form to your project and then reference that type in the descriptor
(typeof(MyHappyForm)).

Import namespaces: Vixen.Module.Editor, Vixen.Sys
(Depending on what you're doing, there are other namespaces that will be
helpful, such as Vixen.Module.Timing, but you'll discover them as you
need them.)

The form itself needs to implement the IEditorUserInterface interface.  The
members to implement are:

OwnerModule: Just need to provide a r/w property for a module reference.
             This is going to be an instance of your useless, worthless
             module.
Sequence:   Again, just a r/w property, but for the sequence you'll be
            editing.  You may want to react to this property assignment.
            This is a good time to grab information from the sequence.
Start:      When there is a sequence to edit (be it new or existing), this
            will be called.  Generally, you show the form in response.
Selection:  You can safely return null for this as no code is making use of it.
            There was originally a purpose for this, but that purpose has
            been reserved for future use.
Save:       A file path is only provided if it is to change.  Otherwise,
            the editor is expected to save the sequence to the same location
            it was loaded from.
IsModified: Return true if the sequence being edited has been modified.

If you're implementing a Winforms editor, then two things are also required
but provided for you by the Form class:

Closing event
Activated event

This is so that the client application that launched you can track what is
up, what is active, and react to changes in those states.

Nothing is assumed about your user interface.  It's assumed that your UI edits
a sequence, can save a sequence, and starts at some defined point in time.  The
rest is up to you and how you interact with your users is entirely undefined.

Stop, close your eyes, and concentrate.  When you open your eyes again, your
module will be complete and built.  If that fails, then build it manually.

IMPORTANT NOTES:
An editor is essentially useless without a sequence to edit.  Sequences are also
module types, and since there is no sequence module that implements the type
of sequence this sample edits (".fil" file), this editor doesn't do anything.
However, it does have code that should give you some ideas of what you would
need to do in order to execute a sequence as an editor and respond to that
execution.

Some highlights from that code:

1. Before you can execute a sequence, a context needs to be created via
   Vixen.Sys.Execution.CreateContext.
2. That context needs to be released, either when execution stops or the
   editor is closed.  Just be sure to pair the create and release in a
   similar fashion -- if you create when the editor is created, release
   when the editor is closed; if you create when starting execution,
   release when execution stops.
3. There are events on the context that will tell you:
   * Program starts/stops executing
   * Sequence within that program starts/stop executing
4. Each sequence has its own timing source (also a module) and that timing
   source is specified in the SequenceStarted event.  It's also available
   from the sequence itself (not shown).