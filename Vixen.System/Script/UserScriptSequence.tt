<#@ template language="C#" debug="true" #>
<#@ assembly name="Vixen.dll" #>
<#@ import namespace="Vixen.Sys" #>
<#@ import namespace="Vixen.Module.CommandSpec" #>
<#@ import namespace="System.Linq" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="Microsoft.CSharp" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Dynamic;
using Vixen.Sys;
using Vixen.Common;
using Vixen.Module.Sequence;
using Vixen.Script;
using CommandStandard;

namespace <#=Namespace#> 
{
	public partial class <#=ClassName #> : UserScriptHost {
		private UserScriptFixture[] _fixtures;
		// Command name : command spec type id
		private Dictionary<string, Guid> _commands = new Dictionary<string, Guid>();

		public <#= ClassName #>() {
			// Need to copy the command dictionary made in code, but in such a way that
			// it can be built when this is executing..
<#
	ICommandSpecModuleInstance commandSpec;
	foreach(string commandName in _commands.Keys) {
		commandSpec = _commands[commandName];
#>
			_commands["<#=commandName#>"] = new Guid("<#=_commands[commandName].TypeId#>");
<# } #>		
		}

		override public ScriptSequenceBase Sequence { 
			get { return base.Sequence; }
			set {
				base.Sequence = value;
				_fixtures =
					value.Fixtures.Select(x => new UserScriptFixture(x)).ToArray();
			}
		}

		// Arg 0: IEnumerable<UserScriptChannel>
		// Arg 1: int startTime
		// Arg 2: int timeSpan
		// Arg 3: Start of command-specific parameters
		protected void _InvokeCommand(string commandName, params object[] args) {
			Guid commandSpecId;
			if(_commands.TryGetValue(commandName, out commandSpecId)) {
				if(args.Length < 3) throw new ArgumentException("Invalid parameter count to invoke a command.");
				// Argument 1: IEnumerable<UserScriptChannel>
				IEnumerable<UserScriptChannel> channels = args[0] as IEnumerable<UserScriptChannel>;
				if(channels == null) throw new ArgumentException("First parameter must be a channel collection.");
				// Argument 2: int (start time)
				int startTime = (int)args[1];
				// Argument 3: int (time span)
				int timeSpan = (int)args[2];
				
				Sequence.InsertData(channels.Select(x => x.Channel).ToArray() , startTime, timeSpan, new Command(commandSpecId, args.Skip(3).ToArray()));
			}
		}

<#
	foreach(string commandName in _commands.Keys) {
		commandSpec = _commands[commandName];
		string commandParameters =
			string.Join(", ",
			(from parameter in commandSpec.Parameters
			select parameter.ToString()).ToArray());
		string parameterNames =
			string.Join(", ",
			(from parameter in commandSpec.Parameters
			select parameter.Name).ToArray());
#>
		// Original name: <#=commandSpec.CommandName#>
		public void <#=commandName#>(IEnumerable<UserScriptChannel> channels, int startTime, int timeSpan, <#=commandParameters#>) {
			_InvokeCommand("<#=commandName#>", channels, startTime, timeSpan, <#=parameterNames#>);
		}

		public void <#=commandName#>(IEnumerable<UserScriptChannel> channels, int timeSpan, <#=commandParameters#>) {
			_InvokeCommand("<#=commandName#>", channels, 0, timeSpan, <#=parameterNames#>);
		}

<# } #>
<# Fixture[] fixtures = _sequence.Fixtures.ToArray();
	for(int i=0; i < fixtures.Length; i++) { #>
		// Original name: <#=fixtures[i].Name#>
		public dynamic <#= ScriptHostGenerator.Mangle(fixtures[i].Name)#> { 
			get { return _fixtures[<#= i #>]; }
		}
<# } #>
	}
}
