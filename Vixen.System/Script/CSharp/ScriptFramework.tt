<#@ template language="C#" debug="true" #>
<#@ assembly name="Vixen.dll" #>
<#@ import namespace="Vixen.Sys" #>
<#@ import namespace="Vixen.Module.Effect" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly Name="System.Core" #>
<#@ assembly Name="Microsoft.CSharp" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Dynamic;
using Vixen.Sys;
using Vixen.Common;
using Vixen.Module.Sequence;
using Vixen.Script;
using CommandStandard;

namespace <#=Namespace#> {
	public partial class <#=ClassName #> : UserScriptHost {
		private UserScriptNode[] _nodes;
		// effect name : effect type id
		private Dictionary<string, Guid> _effects = new Dictionary<string, Guid>();

		public <#= ClassName #>() {
			_nodes = Vixen.Sys.Execution.Nodes.Select(x => new UserScriptNode(x)).ToArray();
<#
	foreach(string effectName in _effects.Keys) {
#>
			_effects["<#=effectName#>"] = new Guid("<#=_effects[effectName].TypeId#>");
<# } #>		
		}

		override public ScriptSequence Sequence { 
			get { return base.Sequence; }
			set {
				base.Sequence = value;
			}
		}

		// Arg 0: IEnumerable<UserScriptChannel>
		// Arg 1: int startTime
		// Arg 2: int timeSpan
		// Arg 3: Start of command-specific parameters
		//protected void _InvokeEffect(string effectName, params object[] args) {
		protected void _InvokeEffect(string effectName, IEnumerable<UserScriptNode> targetNodes, long startTime, long timeSpan, params object[] args) {
			Guid effectId;
			if(_effects.TryGetValue(effectName, out effectId)) {
				//if(args.Length < 3) throw new ArgumentException("Invalid parameter count to invoke an effect.");
				//// Argument 1: IEnumerable<UserScriptChannel>
				//IEnumerable<UserScriptChannel> channels = args[0] as IEnumerable<UserScriptChannel>;
				//if(channels == null) throw new ArgumentException("First parameter must be a channel collection.");
				//// Argument 2: int (start time)
				//int startTime = (int)args[1];
				//// Argument 3: int (time span)
				//int timeSpan = (int)args[2];
				
				//Sequence.InsertData(channels.Select(x => x.Channel).ToArray() , startTime, timeSpan, new Command(effectId, args.Skip(3).ToArray()));
				Sequence.InsertData(targetNodes.Select(x => x.Node).ToArray() , startTime, timeSpan, new Command(effectId, args.ToArray()));
			}
		}

<#
	foreach(string effectName in _effects.Keys) {
		IEffectModuleInstance effect = _effects[effectName];
		string effectParameters =
			string.Join(", ",
			(from parameter in effect.Parameters
			select parameter.ToString()).ToArray());
		string parameterNames =
			string.Join(", ",
			(from parameter in effect.Parameters
			select parameter.Name).ToArray());
#>
		// Original name: <#=effect.EffectName#>
		public void <#=effectName#>(IEnumerable<UserScriptNode> targetNodes, long startTime, long timeSpan, <#=effectParameters#>) {
			_InvokeEffect("<#=effectName#>", targetNodes, startTime, timeSpan, <#=parameterNames#>);
		}

		public void <#=effectName#>(IEnumerable<UserScriptNode> targetNodes, long timeSpan, <#=effectParameters#>) {
			_InvokeEffect("<#=effectName#>", targetNodes, 0, timeSpan, <#=parameterNames#>);
		}

<# } #>
<#
	// This needs to match the node collection that the script created in its constructor.
	ChannelNode[] nodes = Vixen.Sys.Execution.Nodes.ToArray();
	List<string> usedNames = new List<string>();
	for(int i=0; i < nodes.Length; i++) { #>
		// Original name: <#=nodes[i].Name#>
		public dynamic <#= ScriptHostGenerator.Fix(nodes[i].Name, usedNames)#> { 
			get { return _nodes[<#= i #>]; }
		}
<# } #>
	}
}
