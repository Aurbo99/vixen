<#@ template language="C#" debug="true" #>
<#@ assembly name="Vixen.dll" #>
<#@ import namespace="Vixen.Sys" #>
<#@ import namespace="Vixen.Module.Effect" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ assembly Name="System.Core" #>
Option Strict Off

imports System
imports System.Collections.Generic
imports System.Linq
imports System.Text
imports System.Threading
imports System.Dynamic
imports Vixen.Sys
imports Vixen.Common
imports Vixen.Module.Sequence
imports Vixen.Module.Effect
imports Vixen.Script
imports Vixen.Commands

Namespace <#=Namespace#> 
	Partial Public Class <#=ClassName #>
		Inherits UserScriptHost
		'Private _nodes() As UserScriptNode
		Private _nodes
		' Effect name : effect type id
		Private _effects As Dictionary(Of String, Guid)

		Public Sub New
			_nodes = Vixen.Sys.Execution.Nodes.Select(Function(x) New UserScriptNode(x)).ToArray()
			' Need to copy the command dictionary made in code, but in such a way that
			' it can be built when this is executing..
			_effects = New Dictionary(Of String, Guid)
<#
	foreach(string effectName in Effects.Keys) {
#>
			_effects.Add("<#=effectName#>", New Guid("<#=Effects[effectName].TypeId#>"))
<# } #>		
		End Sub

		Public Overrides Property Sequence() As ScriptSequence 
			Get
				Return MyBase.Sequence
			End Get
			Set
				MyBase.Sequence = Value
			End Set
		End Property

		Protected Sub _InvokeEffect(effectName as String, channels as IEnumerable(Of UserScriptNode), startTime as Long, timeSpan as Long, effectName as String, ParamArray args() as object)
			If _effects.TryGetValue(effectName, effectId) Then
				IEffectModuleInstance effect = ApplicationServices.Get(Of IEffectModuleInstance)(effectId);
				effect.TimeSpan = TimeSpan.FromMilliseconds(timeSpan);
				effect.TargetNodes = targetNodes.Select(Function(x) x.Node).ToArray();
				effect.ParameterValues = args;
				Sequence.InsertData(effect, TimeSpan.FromMilliseconds(startTime));
				'Sequence.InsertData(channels.Select(Function(x) x.Node).ToArray() , startTime, timeSpan, New Command(effectId, args.ToArray()))
			End If
		End Sub

' == Effects ==

<#
	foreach(string effectName in Effects.Keys) {
		IEffectModuleDescriptor effect = Effects[effectName];
		string effectParameters =
			string.Join(", ",
			(from parameter in effect.Parameters
			select _Mangle(parameter.Name) + " As " + parameter.Type).ToArray());
		string parameterNames =
			string.Join(", ",
			(from parameter in effect.Parameters
			select _Mangle(parameter.Name)).ToArray());
#>
		' Original name: <#=effect.EffectName#>
		Public Sub <#=effectName#>(targetNodes As IEnumerable(Of UserScriptNode), startTime As Long, timeSpan As Long, <#=effectParameters#>)
			_InvokeEffect("<#=effectName#>", targetNodes, startTime, timeSpan, <#=parameterNames#>)
		End Sub

		Public Sub <#=effectName#>(targetNodes As IEnumerable(Of UserScriptNode), timeSpan As Long, <#=effectParameters#>)
			_InvokeEffect("<#=effectName#>", targetNodes, 0, timeSpan, <#=parameterNames#>)
		End Sub

<# } #>

' == Nodes ==

<#
	// This needs to match the node collection that the script created in its constructor.
	ChannelNode[] nodes = VixenSystem.Nodes.ToArray();
	List<string> usedNames = new List<string>();
	for(int i=0; i < nodes.Length; i++) { #>
		' Original name: <#=nodes[i].Name#>
		Public ReadOnly Property <#= _Fix(nodes[i].Name, usedNames)#>() As Object
			Get
				Return _nodes(<#= i #>)
			End Get
		End Property
<# } #>
	End Class
End Namespace
